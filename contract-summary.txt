================================================================================
SUSHI MASTERCHEF V1 & V2 KILL-MIGRATOR CONTRACTS — REVIEW PACKAGE
================================================================================

PURPOSE
-------
These migrator contracts are set as the `migrator` on SushiSwap's MasterChef (V1)
and MasterChefV2 contracts on Ethereum mainnet. When `migrate(pid)` is called,
instead of converting LP tokens to a new format, the migrator:

1. Sweeps all LP tokens from the Chef to a designated recipient (multisig)
2. Deploys a KillDummyToken (balanceOf only, no transfer/approve) as replacement
3. The Chef stores the dummy as the new LP token, bricking the pool permanently

The contracts are idempotent: if the same LP appears across multiple pids, the
first call sweeps tokens and subsequent calls still brick the pool with a
dummy(balance=0).

DESIGN DECISIONS
----------------
- No tx.origin / operator gate: governance controls when migrator is set; anyone
  can call migrate(pid) but it only changes the pool once per pid anyway
- No migratedLp guard: removed to support duplicate LP pids (same LP in multiple
  pools). Balance > 0 conditional sweep handles this naturally.
- Local IERC20TransferFrom interface: avoids expanding the shared IERC20 import,
  keeps migrator self-contained
- _safeTransferFrom with low-level call: handles nonstandard ERC20s that don't
  return bool
- KillDummyToken has only balanceOf: no transfer/approve means withdraw and
  emergencyWithdraw revert, permanently bricking the pool

TEST RESULTS (all passing)
--------------------------
MasterChefMigratorTransferUnitTest:     15/15 passed
MasterChefV2MigratorTransferUnitTest:   15/15 passed
MasterChefMigratorTransferTest (fork):   3/3  passed  (pinned to block 24_551_130)
MasterChefV2MigratorTransferTest (fork): 3/3  passed  (pinned to block 24_551_130)

Fork tests use vm.createSelectFork pinned to block 24_551_130 for deterministic
CI behavior. Dynamic pool scan runs against a fixed snapshot — pool + LP state
is valid and stable at this block.

CONTRACT FILES
--------------
src/MasterChefMigratorTransfer.sol    — V1 kill-migrator + KillDummyToken
src/MasterChefV2MigratorTransfer.sol  — V2 kill-migrator + KillDummyToken

INTERFACE FILES
---------------
src/interfaces/IMasterChef.sol        — V1 interface (poolInfo struct, migrate, setMigrator)
src/interfaces/IMasterChefV2.sol      — V2 interface (lpToken mapping, migrate, setMigrator)

TEST FILES
----------
test/MasterChefMigratorTransferUnit.t.sol   — 15 unit tests (mock chef, no fork)
test/MasterChefV2MigratorTransferUnit.t.sol — 15 unit tests (mock chef, no fork)
test/MasterChefMigratorTransfer.t.sol       — 3 fork tests against real V1 MasterChef
test/MasterChefV2MigratorTransfer.t.sol     — 3 fork tests against real V2 MasterChef


================================================================================
FLATTENED CONTRACT 1: MasterChefMigratorTransfer.sol  (V1)
================================================================================

// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.6.2;

// lib/forge-std/src/interfaces/IERC20.sol

/// @dev Interface of the ERC20 standard as defined in the EIP.
/// @dev This includes the optional name, symbol, and decimals metadata.
interface IERC20 {
    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
    event Transfer(address indexed from, address indexed to, uint256 value);

    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`
    /// is the new allowance.
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice Returns the amount of tokens in existence.
    function totalSupply() external view returns (uint256);

    /// @notice Returns the amount of tokens owned by `account`.
    function balanceOf(address account) external view returns (uint256);

    /// @notice Moves `amount` tokens from the caller's account to `to`.
    function transfer(address to, uint256 amount) external returns (bool);

    /// @notice Returns the remaining number of tokens that `spender` is allowed
    /// to spend on behalf of `owner`
    function allowance(address owner, address spender) external view returns (uint256);

    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    function approve(address spender, uint256 amount) external returns (bool);

    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.
    /// `amount` is then deducted from the caller's allowance.
    function transferFrom(address from, address to, uint256 amount) external returns (bool);

    /// @notice Returns the name of the token.
    function name() external view returns (string memory);

    /// @notice Returns the symbol of the token.
    function symbol() external view returns (string memory);

    /// @notice Returns the decimals places of the token.
    function decimals() external view returns (uint8);
}

// src/MasterChefMigratorTransfer.sol

/// @dev Local interface for transferFrom selector — keeps migrator self-contained
/// without expanding the shared IERC20 interface.
interface IERC20TransferFrom {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

/// @title MasterChefKillDummyToken
/// @notice A minimal ERC20 that reports a fixed balance for a single holder
/// @dev Intentionally has no transfer/approve functions, which bricks the pool —
/// any attempt by MasterChef to call withdraw or emergencyWithdraw will revert
/// because the dummy token cannot be transferred.
contract MasterChefKillDummyToken {
    /// @notice Balance mapping - only the holder specified in constructor will have a balance
    mapping(address => uint256) private _balances;

    /// @notice Creates a dummy token with a predetermined balance for a specific holder
    /// @param balance The balance to report for the holder
    /// @param holder The address that will hold the balance (should be the MasterChef contract)
    constructor(uint256 balance, address holder) {
        _balances[holder] = balance;
    }

    /// @notice Returns the balance of the specified account
    /// @param account The address to query
    /// @return The balance of the account
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
}

/// @title MasterChefMigratorTransfer
/// @author Sushi
/// @notice Migrator contract that transfers LP tokens to a multisig instead of performing V2->V3 migration
/// @dev This contract is designed to be set as the migrator on the MasterChef (V1) contract on Ethereum
/// mainnet. When MasterChef calls the migrate function, instead of converting LP tokens to a new format,
/// this contract simply transfers all LP tokens to a designated recipient (e.g., a multisig wallet).
///
/// Flow:
/// 1. Owner calls MasterChef.setMigrator(address(this))
/// 2. Anyone calls MasterChef.migrate(pid) for each pool
/// 3. MasterChef calls safeApprove for LP tokens and calls migrate()
/// 4. This contract transfers LP tokens to recipient and returns a KillDummyToken
/// 5. MasterChef stores the KillDummyToken as the new LP token (pool is effectively bricked)
///
/// Security considerations:
/// - Only MasterChef can call migrate() due to the sender check
/// - LP tokens are transferred directly to the immutable recipient address
/// - Idempotent per LP token: first call sweeps balance, subsequent calls (e.g. duplicate
///   LP pids) sweep 0 and still brick the pool with a dummy token
/// - The pool becomes non-functional after migration (KillDummyToken has no transfer function)
/// - Users should withdraw their LP tokens before migration or they will be locked
contract MasterChefMigratorTransfer {
    /// @notice The MasterChef contract that is allowed to call migrate
    address public immutable masterchef;

    /// @notice The recipient address that will receive all migrated LP tokens
    address public immutable recipient;

    /// @notice Emitted when LP tokens are migrated to the recipient
    /// @param lpToken The address of the LP token that was migrated
    /// @param amount The amount of LP tokens transferred
    /// @param recipient The address that received the LP tokens
    /// @param dummyToken The address of the kill dummy token deployed for this pool
    /// @param blockNumber The block number at which the migration occurred
    event Migration(address indexed lpToken, uint256 amount, address indexed recipient, address dummyToken, uint256 blockNumber);

    /// @notice Initializes the migrator with the MasterChef and recipient addresses
    /// @param _masterchef The MasterChef contract address that will call migrate
    /// @param _recipient The address that will receive all LP tokens (e.g., multisig)
    constructor(address _masterchef, address _recipient) {
        require(_masterchef != address(0), "zero masterchef");
        require(_recipient != address(0), "zero recipient");
        masterchef = _masterchef;
        recipient = _recipient;
    }

    /// @notice Migrates LP tokens by transferring them to the recipient
    /// @dev Called by MasterChef during the migration process. MasterChef will have already
    /// called safeApprove for this contract to spend its LP tokens before calling this function.
    /// @param lpToken The LP token to migrate
    /// @return A KillDummyToken that reports the same balance to satisfy MasterChef's balance check
    function migrate(IERC20 lpToken) external returns (IERC20) {
        require(msg.sender == masterchef, "only masterchef");

        uint256 balance = lpToken.balanceOf(masterchef);

        if (balance > 0) {
            _safeTransferFrom(lpToken, masterchef, recipient, balance);
        }

        // Deploy a kill dummy token that reports the expected balance to MasterChef
        // This satisfies the requirement: bal == newLpToken.balanceOf(address(this))
        MasterChefKillDummyToken dummy = new MasterChefKillDummyToken(balance, masterchef);

        emit Migration(address(lpToken), balance, recipient, address(dummy), block.number);

        return IERC20(address(dummy));
    }

    /// @dev Safe transferFrom that handles non-standard ERC20s (no return value)
    function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(IERC20TransferFrom.transferFrom.selector, from, to, value)
        );
        require(success && (data.length == 0 || abi.decode(data, (bool))), "transferFrom failed");
    }
}


================================================================================
FLATTENED CONTRACT 2: MasterChefV2MigratorTransfer.sol  (V2)
================================================================================

// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.6.2;

// lib/forge-std/src/interfaces/IERC20.sol

/// @dev Interface of the ERC20 standard as defined in the EIP.
/// @dev This includes the optional name, symbol, and decimals metadata.
interface IERC20 {
    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
    event Transfer(address indexed from, address indexed to, uint256 value);

    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`
    /// is the new allowance.
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice Returns the amount of tokens in existence.
    function totalSupply() external view returns (uint256);

    /// @notice Returns the amount of tokens owned by `account`.
    function balanceOf(address account) external view returns (uint256);

    /// @notice Moves `amount` tokens from the caller's account to `to`.
    function transfer(address to, uint256 amount) external returns (bool);

    /// @notice Returns the remaining number of tokens that `spender` is allowed
    /// to spend on behalf of `owner`
    function allowance(address owner, address spender) external view returns (uint256);

    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    function approve(address spender, uint256 amount) external returns (bool);

    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.
    /// `amount` is then deducted from the caller's allowance.
    function transferFrom(address from, address to, uint256 amount) external returns (bool);

    /// @notice Returns the name of the token.
    function name() external view returns (string memory);

    /// @notice Returns the symbol of the token.
    function symbol() external view returns (string memory);

    /// @notice Returns the decimals places of the token.
    function decimals() external view returns (uint8);
}

// src/MasterChefV2MigratorTransfer.sol

/// @dev Local interface for transferFrom selector — keeps migrator self-contained
/// without expanding the shared IERC20 interface.
interface IERC20TransferFrom {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

/// @title MasterChefV2KillDummyToken
/// @notice A minimal ERC20 that reports a fixed balance for a single holder
/// @dev Intentionally has no transfer/approve functions, which bricks the pool —
/// any attempt by MasterChefV2 to call withdraw or emergencyWithdraw will revert
/// because the dummy token cannot be transferred.
contract MasterChefV2KillDummyToken {
    /// @notice Balance mapping - only the holder specified in constructor will have a balance
    mapping(address => uint256) private _balances;

    /// @notice Creates a dummy token with a predetermined balance for a specific holder
    /// @param balance The balance to report for the holder
    /// @param holder The address that will hold the balance (should be the MasterChefV2 contract)
    constructor(uint256 balance, address holder) {
        _balances[holder] = balance;
    }

    /// @notice Returns the balance of the specified account
    /// @param account The address to query
    /// @return The balance of the account
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
}

/// @title MasterChefV2MigratorTransfer
/// @author Sushi
/// @notice Migrator contract that transfers LP tokens to a multisig instead of performing V2->V3 migration
/// @dev This contract is designed to be set as the migrator on the MasterChefV2 contract on Ethereum
/// mainnet. When MasterChefV2 calls the migrate function, instead of converting LP tokens to a new format,
/// this contract simply transfers all LP tokens to a designated recipient (e.g., a multisig wallet).
///
/// MasterChefV2 is the "double rewards" contract that sits on top of MasterChef V1, distributing
/// additional SUSHI rewards to specific pools.
///
/// Flow:
/// 1. Owner calls MasterChefV2.setMigrator(address(this))
/// 2. Anyone calls MasterChefV2.migrate(pid) for each pool
/// 3. MasterChefV2 approves this contract for LP tokens and calls migrate()
/// 4. This contract transfers LP tokens to recipient and returns a KillDummyToken
/// 5. MasterChefV2 stores the KillDummyToken as the new LP token (pool is effectively bricked)
///
/// Security considerations:
/// - Only MasterChefV2 can call migrate() due to the sender check
/// - LP tokens are transferred directly to the immutable recipient address
/// - Idempotent per LP token: first call sweeps balance, subsequent calls (e.g. duplicate
///   LP pids) sweep 0 and still brick the pool with a dummy token
/// - The pool becomes non-functional after migration (KillDummyToken has no transfer function)
/// - Users should withdraw their LP tokens before migration or they will be locked
contract MasterChefV2MigratorTransfer {
    /// @notice The MasterChefV2 contract that is allowed to call migrate
    address public immutable masterchefv2;

    /// @notice The recipient address that will receive all migrated LP tokens
    address public immutable recipient;

    /// @notice Emitted when LP tokens are migrated to the recipient
    /// @param lpToken The address of the LP token that was migrated
    /// @param amount The amount of LP tokens transferred
    /// @param recipient The address that received the LP tokens
    /// @param dummyToken The address of the kill dummy token deployed for this pool
    /// @param blockNumber The block number at which the migration occurred
    event Migration(address indexed lpToken, uint256 amount, address indexed recipient, address dummyToken, uint256 blockNumber);

    /// @notice Initializes the migrator with the MasterChefV2 and recipient addresses
    /// @param _masterchefv2 The MasterChefV2 contract address that will call migrate
    /// @param _recipient The address that will receive all LP tokens (e.g., multisig)
    constructor(address _masterchefv2, address _recipient) {
        require(_masterchefv2 != address(0), "zero masterchefv2");
        require(_recipient != address(0), "zero recipient");
        masterchefv2 = _masterchefv2;
        recipient = _recipient;
    }

    /// @notice Migrates LP tokens by transferring them to the recipient
    /// @dev Called by MasterChefV2 during the migration process. MasterChefV2 will have already
    /// approved this contract to spend its LP tokens before calling this function.
    /// @param lpToken The LP token to migrate
    /// @return A KillDummyToken that reports the same balance to satisfy MasterChefV2's balance check
    function migrate(IERC20 lpToken) external returns (IERC20) {
        require(msg.sender == masterchefv2, "only masterchefv2");

        uint256 balance = lpToken.balanceOf(masterchefv2);

        if (balance > 0) {
            _safeTransferFrom(lpToken, masterchefv2, recipient, balance);
        }

        // Deploy a kill dummy token that reports the expected balance to MasterChefV2
        // This satisfies the requirement: bal == newLpToken.balanceOf(address(this))
        MasterChefV2KillDummyToken dummy = new MasterChefV2KillDummyToken(balance, masterchefv2);

        emit Migration(address(lpToken), balance, recipient, address(dummy), block.number);

        return IERC20(address(dummy));
    }

    /// @dev Safe transferFrom that handles non-standard ERC20s (no return value)
    function _safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(IERC20TransferFrom.transferFrom.selector, from, to, value)
        );
        require(success && (data.length == 0 || abi.decode(data, (bool))), "transferFrom failed");
    }
}
